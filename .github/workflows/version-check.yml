name: Smart Auto-Versioning

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  smart-version:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    name: Smart Version Analysis & Auto-Bump
    permissions:
      contents: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        pip install hatch packaging gitpython
        
    - name: Intelligent Version Analysis
      id: analyze
      run: |
        python << 'EOF'
        import os
        import re
        import git
        import subprocess
        from packaging import version
        
        def run_cmd(cmd):
            try:
                result = subprocess.check_output(cmd, shell=True, text=True, cwd='.').strip()
                return result
            except subprocess.CalledProcessError as e:
                print(f"Command failed: {cmd}")
                print(f"Error: {e}")
                raise
        
        def get_version_from_file():
            """Fallback: read version directly from __about__.py"""
            try:
                with open('backend/global_economy_sim/__about__.py', 'r') as f:
                    content = f.read()
                    import re
                    match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
                    if match:
                        return match.group(1)
                    return "0.1.0"  # fallback
            except FileNotFoundError:
                return "0.1.0"  # fallback
        
        def update_version_file(new_version):
            """Update version directly in __about__.py"""
            try:
                with open('backend/global_economy_sim/__about__.py', 'r') as f:
                    content = f.read()
                
                import re
                updated_content = re.sub(
                    r'(__version__\s*=\s*["\'])([^"\']+)(["\'])',
                    f'\\g<1>{new_version}\\g<3>',
                    content
                )
                
                with open('backend/global_economy_sim/__about__.py', 'w') as f:
                    f.write(updated_content)
                
                print(f"âœ… Updated __about__.py with version {new_version}")
                return True
            except Exception as e:
                print(f"âŒ Failed to update version file: {e}")
                return False
        
        def increment_version(current_version, bump_type):
            """Increment version based on bump type"""
            try:
                ver = version.parse(current_version)
                if bump_type == "major":
                    return f"{ver.major + 1}.0.0"
                elif bump_type == "minor":
                    return f"{ver.major}.{ver.minor + 1}.0"
                else:  # patch
                    return f"{ver.major}.{ver.minor}.{ver.micro + 1}"
            except Exception as e:
                print(f"âŒ Error incrementing version: {e}")
                return current_version
        
        def analyze_changes():
            """Analyze git changes to determine version bump type"""
            try:
                # Get the last commit (since this runs on push to main)
                repo = git.Repo('.')
                
                # Get changes in the last commit
                last_commit = repo.head.commit
                if not last_commit.parents:
                    print("â„¹ï¸  Initial commit detected")
                    return "patch", "Initial commit"
                
                changes = last_commit.diff(last_commit.parents[0])
                
                major_indicators = []
                minor_indicators = []
                patch_indicators = []
                
                print("ðŸ” Analyzing code changes...")
                
                for change in changes:
                    file_path = change.a_path or change.b_path
                    if not file_path:
                        continue
                        
                    print(f"  ðŸ“ Analyzing: {file_path}")
                    
                    # Skip version bumps from the bot itself
                    if file_path == 'backend/global_economy_sim/__about__.py':
                        continue
                    
                    # Check file types and change patterns
                    if file_path.endswith(('.py', '.js', '.ts', '.java', '.cpp', '.c')):
                        if change.change_type == 'D':
                            major_indicators.append(f"Deleted core file: {file_path}")
                        elif change.change_type == 'A':
                            if 'api' in file_path.lower() or 'interface' in file_path.lower():
                                minor_indicators.append(f"New API/interface: {file_path}")
                            else:
                                minor_indicators.append(f"New file: {file_path}")
                        elif change.change_type == 'M':
                            # Analyze the actual diff content
                            try:
                                diff_text = str(change.diff)
                                
                                # Major change indicators
                                if any(pattern in diff_text.lower() for pattern in [
                                    'class.*deleted', 'def.*deleted', 'function.*deleted',
                                    'breaking change', 'deprecated', 'removed',
                                    'incompatible', 'migration required'
                                ]):
                                    major_indicators.append(f"Breaking change detected in {file_path}")
                                
                                # Count lines changed (approximate)
                                additions = diff_text.count('+')
                                deletions = diff_text.count('-')
                                total_changes = additions + deletions
                                
                                if total_changes > 100:
                                    if 'api' in file_path.lower() or 'core' in file_path.lower():
                                        major_indicators.append(f"Major refactoring in core file: {file_path} ({total_changes} changes)")
                                    else:
                                        minor_indicators.append(f"Significant changes: {file_path} ({total_changes} changes)")
                                elif total_changes > 20:
                                    minor_indicators.append(f"Medium changes: {file_path} ({total_changes} changes)")
                                else:
                                    patch_indicators.append(f"Small fix: {file_path} ({total_changes} changes)")
                                    
                                # Feature indicators
                                if any(pattern in diff_text.lower() for pattern in [
                                    'def ', 'class ', 'function ', 'new.*feature',
                                    'add.*method', 'implement'
                                ]):
                                    minor_indicators.append(f"New functionality in {file_path}")
                                    
                            except Exception as e:
                                print(f"  âš ï¸  Could not analyze diff for {file_path}: {e}")
                                patch_indicators.append(f"Modified: {file_path}")
                    
                    # Configuration changes
                    elif file_path.endswith(('.json', '.yaml', '.yml', '.toml', '.cfg', '.ini')):
                        if 'package.json' in file_path or 'pyproject.toml' in file_path:
                            minor_indicators.append(f"Package configuration updated: {file_path}")
                        else:
                            patch_indicators.append(f"Config updated: {file_path}")
                    
                    # Documentation
                    elif file_path.endswith(('.md', '.rst', '.txt')):
                        patch_indicators.append(f"Documentation updated: {file_path}")
                    
                    # Tests
                    elif 'test' in file_path.lower() or file_path.endswith('_test.py'):
                        patch_indicators.append(f"Tests updated: {file_path}")
                
                # Analyze commit message for additional context
                commit_msg = last_commit.message.lower()
                if any(word in commit_msg for word in ['break', 'breaking', 'major', 'incompatible']):
                    major_indicators.append(f"Breaking change indicated in commit: {last_commit.message[:50]}...")
                elif any(word in commit_msg for word in ['feat', 'feature', 'add', 'new', 'implement']):
                    minor_indicators.append(f"Feature indicated in commit: {last_commit.message[:50]}...")
                elif any(word in commit_msg for word in ['fix', 'bug', 'patch', 'hotfix']):
                    patch_indicators.append(f"Fix indicated in commit: {last_commit.message[:50]}...")
                
                print(f"\nðŸ“Š Analysis Results:")
                print(f"  ðŸš¨ Major indicators: {len(major_indicators)}")
                for indicator in major_indicators[:3]:  # Show first 3
                    print(f"    - {indicator}")
                    
                print(f"  âœ¨ Minor indicators: {len(minor_indicators)}")
                for indicator in minor_indicators[:3]:
                    print(f"    - {indicator}")
                    
                print(f"  ðŸ› Patch indicators: {len(patch_indicators)}")
                for indicator in patch_indicators[:3]:
                    print(f"    - {indicator}")
                
                # Decision logic
                if major_indicators:
                    return "major", major_indicators[0]
                elif minor_indicators:
                    return "minor", minor_indicators[0]
                elif patch_indicators:
                    return "patch", patch_indicators[0]
                else:
                    return "patch", "Default patch bump for changes"
                    
            except Exception as e:
                print(f"âŒ Error during analysis: {e}")
                return "patch", "Fallback patch bump due to analysis error"
        
        # Ensure we're in the right directory
        os.chdir('.')
        print(f"ðŸ“‚ Working directory: {os.getcwd()}")
        
        # Get current version (file-based only for reliability)
        current_version = get_version_from_file()
        print(f"ðŸ“¦ Current version: {current_version}")
        
        # Check if this is a version bump commit from the bot
        repo = git.Repo('.')
        last_commit = repo.head.commit
        if "ðŸ¤– Auto-bump version" in last_commit.message:
            print("â„¹ï¸  This is a version bump commit from the bot, skipping analysis")
            import sys
            sys.exit(0)
        
        # Analyze and determine bump type
        bump_type, reason = analyze_changes()
        print(f"\nðŸŽ¯ Decision: {bump_type.upper()} bump")
        print(f"ðŸ“ Reason: {reason}")
        
        # Calculate new version
        new_version = increment_version(current_version, bump_type)
        print(f"\nâ¬†ï¸  Calculated new version: {current_version} â†’ {new_version}")
        
        # Update version file
        if update_version_file(new_version):
            print(f"âœ… Version bumped: {current_version} â†’ {new_version}")
        else:
            print(f"âŒ Failed to update version")
            import sys
            sys.exit(1)
        
        # Output for GitHub
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"old-version={current_version}\n")
            f.write(f"new-version={new_version}\n")
            f.write(f"bump-type={bump_type}\n")
            f.write(f"reason={reason}\n")
            
        # Create detailed summary
        with open("version_summary.txt", "w") as f:
            bump_emoji = {"major": "ðŸš¨", "minor": "âœ¨", "patch": "ðŸ›"}
            bump_desc = {"major": "Breaking changes", "minor": "New features", "patch": "Bug fixes"}
            
            f.write(f"## ðŸ¤– Smart Auto-Version Update\n\n")
            f.write(f"**{current_version}** â†’ **{new_version}**\n\n")
            f.write(f"**Type:** {bump_type.upper()} {bump_emoji[bump_type]} - {bump_desc[bump_type]}\n\n")
            f.write(f"### ðŸ§  AI Analysis\n")
            f.write(f"**Decision Reason:** {reason}\n\n")
            f.write(f"### Details\n")
            f.write(f"- Previous version: `{current_version}`\n")
            f.write(f"- New version: `{new_version}`\n")
            f.write(f"- Bump type: {bump_type.upper()}\n")
            f.write(f"- Analysis: Automatic based on code changes\n\n")
            f.write(f"---\n")
            f.write(f"*ðŸš€ This version will be automatically tagged and released.*")
            
        EOF
        
    - name: Commit version bump
      run: |
        git config user.name "smart-versioning[bot]"
        git config user.email "smart-versioning[bot]@users.noreply.github.com"
        git add backend/global_economy_sim/__about__.py
        git commit -m "ðŸ¤– Auto-bump version ${{ steps.analyze.outputs.old-version }} â†’ ${{ steps.analyze.outputs.new-version }} (${{ steps.analyze.outputs.bump-type }})"
        git push origin main
        
    - name: Create and push tag
      run: |
        git tag -a "v${{ steps.analyze.outputs.new-version }}" -m "ðŸ¤– Smart auto-release v${{ steps.analyze.outputs.new-version }}"
        git push origin "v${{ steps.analyze.outputs.new-version }}"
        echo "âœ… Created and pushed tag v${{ steps.analyze.outputs.new-version }}"
        
    - name: Create summary
      run: |
        cat version_summary.txt >> $GITHUB_STEP_SUMMARY

  auto-release:
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    name: Create Release
    permissions:
      contents: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install Hatch
      run: pip install hatch
      
    - name: Build package
      run: hatch build
      
    - name: Generate release notes
      id: release-notes
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        
        # Generate changelog from recent commits
        cat << EOF > release_notes.md
        ## ðŸš€ Global Economy Simulation v$VERSION
        
        > *This release was automatically created by smart AI-powered version analysis*
        
        ### What's Changed
        
        $(git log --pretty=format:"- %s (%an)" $(git describe --tags --abbrev=0 HEAD^)..HEAD | head -10)
        
        ### Installation
        
        \`\`\`bash
        pip install global-economy-sim==$VERSION
        \`\`\`
        
        ### Development Setup
        
        \`\`\`bash
        git clone https://github.com/filip-herceg/economy-simulation.git
        cd economy-simulation
        hatch env create
        hatch shell
        \`\`\`
        
        **Full Changelog**: https://github.com/filip-herceg/economy-simulation/compare/$(git describe --tags --abbrev=0 HEAD^)...v$VERSION
        EOF
        
    - name: Create GitHub Release
      id: create-release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref_name }}
        release_name: "ðŸ¤– Smart Release v${{ steps.release-notes.outputs.version }}"
        body_path: release_notes.md
        draft: false
        prerelease: false

  pr-preview:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    name: Preview Version Impact
    
    steps:
    - name: Checkout PR
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: pip install hatch packaging gitpython
      
    - name: Analyze PR Impact
      run: |
        python << 'EOF'
        import git
        import subprocess
        import re
        
        def get_version_from_file():
            """Read version directly from __about__.py"""
            try:
                with open('backend/global_economy_sim/__about__.py', 'r') as f:
                    content = f.read()
                    match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
                    if match:
                        return match.group(1)
                    return "0.1.0"  # fallback
            except FileNotFoundError:
                return "0.1.0"  # fallback
        
        # Get base version
        subprocess.run(["git", "checkout", "origin/main"], check=True)
        base_version = get_version_from_file()
        
        # Go back to PR
        subprocess.run(["git", "checkout", "-"], check=True)
        
        # Analyze changes (simplified for PR preview)
        repo = git.Repo('.')
        
        # Get diff between main and PR
        main_commit = repo.commit('origin/main')
        pr_commit = repo.head.commit
        changes = main_commit.diff(pr_commit)
        
        total_files = len(changes)
        python_files = len([c for c in changes if (c.a_path or c.b_path or '').endswith('.py')])
        new_files = len([c for c in changes if c.change_type == 'A'])
        deleted_files = len([c for c in changes if c.change_type == 'D'])
        
        # Simple heuristic for PR preview
        if deleted_files > 0 or total_files > 10:
            predicted_bump = "MAJOR ðŸš¨"
        elif new_files > 0 or python_files > 3:
            predicted_bump = "MINOR âœ¨"
        else:
            predicted_bump = "PATCH ðŸ›"
        
        summary = f"""## ðŸ”® Smart Version Preview
        
        When this PR is merged, the smart versioning system will likely apply a **{predicted_bump}** bump.
        
        ### ðŸ“Š Change Analysis
        - **Files changed:** {total_files}
        - **Python files:** {python_files}
        - **New files:** {new_files}
        - **Deleted files:** {deleted_files}
        
        ### ðŸ“¦ Predicted Version Change
        **{base_version}** â†’ **{predicted_bump}**
        
        ---
        *This is a preview. The actual version will be determined by AI analysis when merged to main.*
        """
        
        with open("pr_summary.txt", "w") as f:
            f.write(summary)
        EOF
        
    - name: Comment PR with preview
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const summary = fs.readFileSync('pr_summary.txt', 'utf8');
          
          const comments = await github.rest.issues.listComments({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
          });
          
          const botComment = comments.data.find(comment => 
            comment.user.login === 'github-actions[bot]' && 
            comment.body.includes('ðŸ”® Smart Version Preview')
          );
          
          if (botComment) {
            await github.rest.issues.updateComment({
              comment_id: botComment.id,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          } else {
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          }

  smart-release:
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    name: Create Release
    permissions:
      contents: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install Hatch
      run: pip install hatch
      
    - name: Build package
      run: hatch build
      
    - name: Generate release notes
      id: release-notes
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        
        # Generate changelog from recent commits
        cat << EOF > release_notes.md
        ## ðŸš€ Global Economy Simulation v$VERSION
        
        ### What's Changed
        
        $(git log --pretty=format:"- %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD | head -20)
        
        ### Installation
        
        \`\`\`bash
        pip install global-economy-sim==$VERSION
        \`\`\`
        
        ### Development Setup
        
        \`\`\`bash
        git clone https://github.com/filip-herceg/economy-simulation.git
        cd economy-simulation
        hatch env create
        hatch shell
        \`\`\`
        
        **Full Changelog**: https://github.com/filip-herceg/economy-simulation/compare/$(git describe --tags --abbrev=0 HEAD^)...v$VERSION
        EOF
        
    - name: Create GitHub Release
      id: create-release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref_name }}
        release_name: "Global Economy Simulation v${{ steps.release-notes.outputs.version }}"
        body_path: release_notes.md
        draft: false
        prerelease: ${{ contains(github.ref_name, 'alpha') || contains(github.ref_name, 'beta') || contains(github.ref_name, 'rc') }}
        
    - name: Upload build artifacts
      if: success()
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create-release.outputs.upload_url }}
        asset_path: ./dist/
        asset_name: economy-simulation-distributions
        asset_content_type: application/zip
